//=============================================================================
// Release information
// Design version: sifive_sesame_rel3_190711
// Document version: OMC-V1.4-UG-R2.11, OMC-V1.4-IG-R1.00-SESAME
// Release generated at Thu Jul 11 15:30:19 2019
//=============================================================================

// ============================================================================
// Description:    
// =============================================================================

`ifndef OIC_INTERFACE
`define OIC_INTERFACE


`include "oic_define.h"

// ============================================================================
// ============================================================================
// ============================================================================
// Description: interface define for design
// =============================================================================
// =============================================================================
// =============================================================================
interface orbit_if_HXI #(
  parameter DECODE_WIDTH = 2,
  parameter ROUTE_WIDTH  = 2,
  parameter ID_WIDTH     = 4,
  parameter ADDR_WIDTH   = 32,
  parameter USER_WIDTH   = 1,
  parameter DATA_WIDTH   = 32,
  // auto calculated
  parameter WSTRB_WIDTH  = DATA_WIDTH / 8,
  parameter A_PAYLD_WIDTH = 1 + DECODE_WIDTH + 4 + 4 + ID_WIDTH + ADDR_WIDTH + 13 + 2 + 2 + USER_WIDTH + ROUTE_WIDTH,
  parameter W_PAYLD_WIDTH = WSTRB_WIDTH + DATA_WIDTH + 1,
  parameter R_PAYLD_WIDTH = ID_WIDTH + 2 + DATA_WIDTH + 1 + USER_WIDTH + ROUTE_WIDTH,
  parameter B_PAYLD_WIDTH = ID_WIDTH + 2 + USER_WIDTH + ROUTE_WIDTH
);
  logic AV, AR; logic [A_PAYLD_WIDTH -1:0] AP;
  logic WV, WR; logic [W_PAYLD_WIDTH -1:0] WP;
  logic RV, RR; logic [R_PAYLD_WIDTH -1:0] RP;
  logic BV, BR; logic [B_PAYLD_WIDTH -1:0] BP;

  modport si (
    input  AV, output AR, input  AP,
    input  WV, output WR, input  WP,
    output RV, input  RR, output RP,
    output BV, input  BR, output BP
  );

  modport mi (
    output AV, input  AR, output AP,
    output WV, input  WR, output WP,
    input  RV, output RR, input  RP,
    input  BV, output BR, input  BP
  );

  modport status (
    output AV, output AR, output AP,
    output WV, output WR, output WP,
    output RV, output RR, output RP,
    output BV, output BR, output BP
  );

  modport monitor (
    input AV, input AR, input AP,
    input WV, input WR, input WP,
    input RV, input RR, input RP,
    input BV, input BR, input BP
  );


`ifdef OIC_DEBUG

//pragma protect begin_protected
//pragma protect key_keyowner=Cadence Design Systems.
//pragma protect key_keyname=CDS_KEY
//pragma protect key_method=RC5
//pragma protect key_block
02DTAAVBGUUKvVX89cVkdXbxdiXv72jnBsXcKuAs3SH4hreaOZODgrjRwAYd7x5K
c5oSYysV4cV7H1E97GYV1D54p6aSORrvTkYumIRXjNP+D4q+Rp5HmsRBc/f4xKkC
cckMQLR/gGvNZRam/wF16yWbic2WJwmzzgy+f/JpWIjMdyQks0KogA==
//pragma protect end_key_block
//pragma protect digest_block
7oaS4mYmrOC1Z4m2A3Y9FGFekIc=
//pragma protect end_digest_block
//pragma protect data_block
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
//pragma protect end_data_block
//pragma protect digest_block
NqyQFtoCfoSWoJ3a91kraVEGMUw=
//pragma protect end_digest_block
//pragma protect end_protected
  
`endif

endinterface


// =============================================================================
interface orbit_if_EHXI #(
  parameter ID_WIDTH      = 4,     // this ID_WIDTH includes ROUTE_WIDTH.
  parameter ADDR_WIDTH    = 32,
  parameter USER_WIDTH    = 1,
  parameter DATA_WIDTH    = 32,
  parameter QINDEX_WIDTH  = 1,
  parameter QTHIRST_WIDTH = 1 << QINDEX_WIDTH,
  // derived parameters.
  parameter WSTRB_WIDTH  = DATA_WIDTH / 8
);

  logic                                  awrite;
  logic                                  avalid;
  logic                                  aready;
  logic  [3:0]                           aqos;
  logic  [3:0]                           alen;
  logic  [ID_WIDTH-1:0]                  aid;
  logic  [ADDR_WIDTH-1:0]                aaddr;
  logic  [2:0]                           asize;
  logic  [1:0]                           aburst;
  logic  [3:0]                           acache;
  logic  [2:0]                           aprot;
  logic                                  alock;
  logic  [1:0]                           asnoop;
  logic  [1:0]                           adomain;
  logic  [USER_WIDTH-1:0]                auser;

  logic                                  rvalid;
  logic                                  rready;
  logic  [ID_WIDTH-1:0]                  rid;
  logic  [1:0]                           rresp;
  logic  [DATA_WIDTH-1:0]                rdata;
  logic                                  rlast;
  logic  [USER_WIDTH-1:0]                ruser;

  logic                                  wvalid;
  logic                                  wready;
  logic  [WSTRB_WIDTH-1:0]               wstrb;
  logic  [DATA_WIDTH-1:0]                wdata;
  logic                                  wlast;

  logic                                  bvalid;
  logic                                  bready;
  logic  [ID_WIDTH-1:0]                  bid;
  logic  [1:0]                           bresp;
  logic  [USER_WIDTH-1:0]                buser;

  logic  [QTHIRST_WIDTH-1:0]             qthirst;
  logic  [QINDEX_WIDTH-1:0]              qindex;
  logic                                  qcongest;

  modport si (
    input     awrite,
    input     avalid,
    output    aready,
    input     aqos,
    input     alen,
    input     aid,
    input     aaddr,
    input     asize,
    input     aburst,
    input     acache,
    input     aprot,
    input     alock,
    input     asnoop,
    input     adomain,
    input     auser,

    output    rvalid,
    input     rready,
    output    rid,
    output    rresp,
    output    rdata,
    output    rlast,
    output    ruser,

    input     wvalid,
    output    wready,
    input     wstrb,
    input     wdata,
    input     wlast,

    output    bvalid,
    input     bready,
    output    bid,
    output    bresp,
    output    buser,

    input     qthirst,
    input     qindex,
    output    qcongest
  );

  modport mi (
    output    awrite,
    output    avalid,
    input     aready,
    output    aqos,
    output    alen,
    output    aid,
    output    aaddr,
    output    asize,
    output    aburst,
    output    acache,
    output    aprot,
    output    alock,
    output    asnoop,
    output    adomain,
    output    auser,

    input     rvalid,
    output    rready,
    input     rid,
    input     rresp,
    input     rdata,
    input     rlast,
    input     ruser,

    output    wvalid,
    input     wready,
    output    wstrb,
    output    wdata,
    output    wlast,

    input     bvalid,
    output    bready,
    input     bid,
    input     bresp,
    input     buser,

    output    qthirst,
    output    qindex,
    input     qcongest
  );
endinterface


// =============================================================================
interface orbit_if_APB #(
  parameter ADDR_WIDTH   = 32,
  parameter DATA_WIDTH   = 32,
  // auto calculated
  parameter STRB_WIDTH   = DATA_WIDTH / 8
);
  // APB Interface
  logic                       psel;
  logic                       penable;
  logic   [ADDR_WIDTH-1:0]    paddr;
  logic   [2:0]               pprot;       // [1]: "0" is secure access
  logic   [STRB_WIDTH-1:0]    pstrb;

  logic                       pwrite;
  logic   [DATA_WIDTH-1:0]    pwdata;

  logic                       pready;
  logic                       pslverr;
  logic   [DATA_WIDTH-1:0]    prdata;

  modport si (
    input psel, penable, paddr, pprot, pstrb, pwrite, pwdata,
    output pready, pslverr, prdata
  );

  modport mi (
    output psel, penable, paddr, pprot, pstrb, pwrite, pwdata,
    input pready, pslverr, prdata
  );
endinterface

// =============================================================================
interface orbit_if_AHB #(
  parameter ADDR_WIDTH   = 32,
  parameter DATA_WIDTH   = 32,
  parameter USER_WIDTH   = 1
);
  // AHB slave interface
  logic                         hbusreq;
  logic                         hgrant ;
  logic [ADDR_WIDTH -1:0]       haddr  ;
  logic [1:0]                   htrans ;
  logic                         hwrite ;
  logic [2:0]                   hsize  ;
  logic [2:0]                   hburst ;
  logic [3:0]                   hprot  ;
  logic [USER_WIDTH -1:0]       hauser ;

  logic [DATA_WIDTH -1:0]       hwdata ;
  logic [USER_WIDTH -1:0]       hwuser ;
  logic [DATA_WIDTH -1:0]       hrdata ;
  logic [USER_WIDTH -1:0]       hruser ;
  logic                         hready ;
  logic [1:0]                   hresp  ;

  modport si (
    input hbusreq,
    output  hgrant ,
    input haddr ,
    input htrans,
    input hwrite,
    input hsize ,
    input hburst,
    input hprot ,
    input hauser,

    input hwdata,
    input hwuser,
    output  hrdata,
    output  hruser,
    output  hready,
    output  hresp 
  );

  modport mi (
    output hbusreq,
    input  hgrant ,
    output haddr ,
    output htrans,
    output hwrite,
    output hsize ,
    output hburst,
    output hprot ,
    output hauser,

    output hwdata,
    output hwuser,
    input  hrdata,
    input  hruser,
    input  hready,
    input  hresp 
  );
endinterface


// =============================================================================
interface orbit_if_AHB_lite #(
  parameter ADDR_WIDTH   = 32,
  parameter DATA_WIDTH   = 32,
  parameter USER_WIDTH   = 1
);

//-------------------------------------------------------------------------------------
//                                           |  HSEL  | HREADY input |  HREADY output |
//-------------------------------------------|----------------------------------------|
// SLAVE if  | AHB-lite slave if             |   O    |       O      |      O         |
// SLAVE if  |-------------------------------|----------------------------------------|
// SLAVE if  | AHB-lite mirrored master if   |   X    |       X      |      O         |
//-------------------------------------------|----------------------------------------|
// MASTER if | AHB-lite mirrored slave if    |   O    |       O      |      O         |
// MASTER if |-------------------------------|----------------------------------------|
// MASTER if | AHB-lite master if            |   X    |       O      |      X         | 
//-------------------------------------------------------------------------------------

  // AHB lite interface
  logic [ADDR_WIDTH -1:0]       haddr;
  logic [1:0]                   htrans;
  logic                         hwrite;
  logic [2:0]                   hsize;
  logic [2:0]                   hburst;
  logic                         hnonsec;
  logic [3:0]                   hprot;
  logic [USER_WIDTH -1:0]       hauser;

  logic [DATA_WIDTH -1:0]       hwdata;
  logic [USER_WIDTH -1:0]       hwuser;
  logic [DATA_WIDTH -1:0]       hrdata;
  logic [USER_WIDTH -1:0]       hruser;
  logic                         hready;       // !!CAUTION!! direction is changed according to the if type.
  logic                         hreadyout;   // !!CAUTION!! direction is changed according to the if type.
  logic                         hresp;
  logic                         hmastlock;
  logic                         hsel;


  modport si (
    input   haddr,
    input   htrans,
    input   hwrite,
    input   hsize,
    input   hburst,
    input   hnonsec,
    input   hprot,
    input   hauser,

    input   hwdata,
    input   hwuser,
    output  hrdata,
    output  hruser,
    output  hready,
    input   hreadyout,
    output  hresp,
    input   hsel
  );

  modport mi (
    output  haddr,
    output  htrans,
    output  hwrite,
    output  hsize,
    output  hburst,
    output  hnonsec,
    output  hprot,
    output  hauser,

    output  hwdata,
    output  hwuser,
    input   hrdata,
    input   hruser,
    input   hready,
    output  hreadyout,
    input   hresp,
    output  hsel
  );
endinterface


// =============================================================================
interface orbit_if_LDA_DL_VC #(
  parameter M_DECODE_WIDTH = 2,
  parameter M_ROUTE_WIDTH  = 2,
  parameter M_ID_WIDTH     = 4,
  parameter M_ADDR_WIDTH   = 32,
  parameter M_USER_WIDTH   = 1,
  parameter M_DATA_WIDTH   = 32,

  parameter R_DECODE_WIDTH = 2,
  parameter R_ROUTE_WIDTH  = 2,
  parameter R_ID_WIDTH     = 4,
  parameter R_ADDR_WIDTH   = 32,
  parameter R_USER_WIDTH   = 1,
  parameter R_DATA_WIDTH   = 32,
  // auto calculated
  parameter M_WSTRB_WIDTH  = M_DATA_WIDTH / 8,
  parameter M_A_PAYLD_WIDTH = 1 + M_DECODE_WIDTH + 4 + 4 + M_ID_WIDTH + M_ADDR_WIDTH + 13 + 2 + 2 + M_USER_WIDTH + M_ROUTE_WIDTH,
  parameter M_W_PAYLD_WIDTH = M_WSTRB_WIDTH + M_DATA_WIDTH + 1,
  parameter M_R_PAYLD_WIDTH = M_ID_WIDTH + 2 + M_DATA_WIDTH + 1 + M_USER_WIDTH + M_ROUTE_WIDTH,
  parameter M_B_PAYLD_WIDTH = M_ID_WIDTH + 2 + M_USER_WIDTH + M_ROUTE_WIDTH,

  parameter R_WSTRB_WIDTH  = R_DATA_WIDTH / 8,
  parameter R_A_PAYLD_WIDTH = 1 + R_DECODE_WIDTH + 4 + 4 + R_ID_WIDTH + R_ADDR_WIDTH + 13 + 2 + 2 + R_USER_WIDTH + R_ROUTE_WIDTH,
  parameter R_W_PAYLD_WIDTH = R_WSTRB_WIDTH + R_DATA_WIDTH + 1,
  parameter R_R_PAYLD_WIDTH = R_ID_WIDTH + 2 + R_DATA_WIDTH + 1 + R_USER_WIDTH + R_ROUTE_WIDTH,
  parameter R_B_PAYLD_WIDTH = R_ID_WIDTH + 2 + R_USER_WIDTH + R_ROUTE_WIDTH,

  parameter A_PAYLD_WIDTH = M_A_PAYLD_WIDTH >= R_R_PAYLD_WIDTH ? M_A_PAYLD_WIDTH : R_R_PAYLD_WIDTH,
  parameter W_PAYLD_WIDTH = M_W_PAYLD_WIDTH,
  parameter R_PAYLD_WIDTH = M_R_PAYLD_WIDTH,
  parameter B_PAYLD_WIDTH = M_B_PAYLD_WIDTH >= R_W_PAYLD_WIDTH && M_B_PAYLD_WIDTH >= R_A_PAYLD_WIDTH ? M_B_PAYLD_WIDTH :
                            R_W_PAYLD_WIDTH >= M_B_PAYLD_WIDTH && R_W_PAYLD_WIDTH >= R_A_PAYLD_WIDTH ? R_W_PAYLD_WIDTH : R_A_PAYLD_WIDTH
);
  logic tx_clk, tx_clk2, tx_reset_n;
  logic rx_clk, rx_clk2, rx_reset_n;
  logic A_rd_en, A_wr_en; logic [A_PAYLD_WIDTH +1 -1:0] A_wr_data;
  logic W_rd_en, W_wr_en; logic [W_PAYLD_WIDTH +1 -1:0] W_wr_data;
  logic R_rd_en, R_wr_en; logic [R_PAYLD_WIDTH +1 -1:0] R_wr_data;
  logic B_rd_en, B_wr_en; logic [B_PAYLD_WIDTH +1 -1:0] B_wr_data;
  logic tx_pcken, rx_pcken;
  logic pd_req, pd_ack, tx_pwr_state, rx_pwr_state;
  logic r_pd_req, r_pd_ack, r_tx_pwr_state, r_rx_pwr_state;
  logic rB_rd_en, rB_wr_en, rR_rd_en, rR_wr_en;
  logic rA_rd_en, rA_wr_en, rW_rd_en, rW_wr_en;

  modport si (
    input  tx_clk, tx_clk2, tx_reset_n, 
           A_wr_en, A_wr_data, W_wr_en, W_wr_data, R_rd_en, B_rd_en, 
           tx_pcken, pd_req, tx_pwr_state, r_pd_ack, r_rx_pwr_state, 
           rB_wr_en, rR_wr_en, rA_rd_en, rW_rd_en,
    output rx_clk, rx_clk2, rx_reset_n,
           A_rd_en, W_rd_en, R_wr_en, R_wr_data, B_wr_en, B_wr_data,
           rx_pcken, pd_ack, rx_pwr_state, r_pd_req, r_tx_pwr_state,
           rB_rd_en, rR_rd_en, rA_wr_en, rW_wr_en
  );

  modport mi (
    output tx_clk, tx_clk2, tx_reset_n, 
           A_wr_en, A_wr_data, W_wr_en, W_wr_data, R_rd_en, B_rd_en, 
           tx_pcken, pd_req, tx_pwr_state, r_pd_ack, r_rx_pwr_state, 
           rB_wr_en, rR_wr_en, rA_rd_en, rW_rd_en,
    input  rx_clk, rx_clk2, rx_reset_n,
           A_rd_en, W_rd_en, R_wr_en, R_wr_data, B_wr_en, B_wr_data,
           rx_pcken, pd_ack, rx_pwr_state, r_pd_req, r_tx_pwr_state,
           rB_rd_en, rR_rd_en, rA_wr_en, rW_wr_en
  );

endinterface

// =============================================================================
interface orbit_if_LDA #(
  parameter DECODE_WIDTH = 1,
  parameter ROUTE_WIDTH  = 0,
  parameter ID_WIDTH     = 9,
  parameter ADDR_WIDTH   = 40,
  parameter USER_WIDTH   = 1,
  parameter DATA_WIDTH   = 128,
  // auto calculated
  parameter WSTRB_WIDTH  = DATA_WIDTH / 8,
  parameter A_PAYLD_WIDTH = 1 + DECODE_WIDTH + 4 + 4 + ID_WIDTH + ADDR_WIDTH + 13 + 2 + 2 + USER_WIDTH + ROUTE_WIDTH,
  parameter W_PAYLD_WIDTH = WSTRB_WIDTH + DATA_WIDTH + 1,
  parameter R_PAYLD_WIDTH = ID_WIDTH + 2 + DATA_WIDTH + 1 + USER_WIDTH + ROUTE_WIDTH,
  parameter B_PAYLD_WIDTH = ID_WIDTH + 2 + USER_WIDTH + ROUTE_WIDTH
);
  logic tx_clk, tx_clk2, tx_reset_n;
  logic rx_clk, rx_clk2, rx_reset_n;
  logic A_rd_en, A_wr_en; logic [A_PAYLD_WIDTH +1 -1:0] A_wr_data;
  logic W_rd_en, W_wr_en; logic [W_PAYLD_WIDTH +1 -1:0] W_wr_data;
  logic R_rd_en, R_wr_en; logic [R_PAYLD_WIDTH +1 -1:0] R_wr_data;
  logic B_rd_en, B_wr_en; logic [B_PAYLD_WIDTH +1 -1:0] B_wr_data;
  logic pcken;
  //logic WL_rd_en, WL_wr_en;
  logic pd_req, pd_ack, tx_pwr_state, rx_pwr_state;

  modport si (
    input  tx_clk, tx_clk2, tx_reset_n, 
           A_wr_en, A_wr_data, W_wr_en, W_wr_data, R_rd_en, B_rd_en, 
           pcken, pd_req, tx_pwr_state,
    output rx_clk, rx_clk2, rx_reset_n,
           A_rd_en, W_rd_en, R_wr_en, R_wr_data, B_wr_en, B_wr_data,
           pd_ack, rx_pwr_state
  );

  modport mi (
    output tx_clk, tx_clk2, tx_reset_n, 
           A_wr_en, A_wr_data, W_wr_en, W_wr_data, R_rd_en, B_rd_en, 
           pcken, pd_req, tx_pwr_state,
    input  rx_clk, rx_clk2, rx_reset_n,
           A_rd_en, W_rd_en, R_wr_en, R_wr_data, B_wr_en, B_wr_data,
           pd_ack, rx_pwr_state
  );

endinterface

// =============================================================================
interface orbit_if_LDA_TL #(
  parameter DECODE_WIDTH = 2,
  parameter ROUTE_WIDTH  = 2,
  parameter ID_WIDTH     = 4,
  parameter ADDR_WIDTH   = 32,
  parameter USER_WIDTH   = 1,
  parameter DATA_WIDTH   = 32,
  // auto calculated
  parameter WSTRB_WIDTH  = DATA_WIDTH / 8,
  parameter A_PAYLD_WIDTH = 1 + DECODE_WIDTH + 4 + 4 + ID_WIDTH + ADDR_WIDTH + 13 + 2 + 2 + USER_WIDTH + ROUTE_WIDTH,
  parameter W_PAYLD_WIDTH = WSTRB_WIDTH + DATA_WIDTH + 1,
  parameter R_PAYLD_WIDTH = ID_WIDTH + 2 + DATA_WIDTH + 1 + USER_WIDTH + ROUTE_WIDTH,
  parameter B_PAYLD_WIDTH = ID_WIDTH + 2 + USER_WIDTH + ROUTE_WIDTH,
  parameter A_T_PAYLD_WIDTH = A_PAYLD_WIDTH / 2 == 0 ? A_PAYLD_WIDTH / 2 : ((A_PAYLD_WIDTH +1)/2),
  parameter W_T_PAYLD_WIDTH = W_PAYLD_WIDTH / 2 == 0 ? W_PAYLD_WIDTH / 2 : ((W_PAYLD_WIDTH +1)/2),
  parameter R_T_PAYLD_WIDTH = R_PAYLD_WIDTH / 2 == 0 ? R_PAYLD_WIDTH / 2 : ((R_PAYLD_WIDTH +1)/2),
  parameter B_T_PAYLD_WIDTH = B_PAYLD_WIDTH / 2 == 0 ? B_PAYLD_WIDTH / 2 : ((B_PAYLD_WIDTH +1)/2)
);
  logic tx_clk, tx_clk2, tx_reset_n;
  logic rx_clk, rx_clk2, rx_reset_n;
  logic A_rd_en, A_wr_en; logic [A_T_PAYLD_WIDTH +1 -1:0] A_wr_data;
  logic W_rd_en, W_wr_en; logic [W_T_PAYLD_WIDTH +1 -1:0] W_wr_data;
  logic R_rd_en, R_wr_en; logic [R_T_PAYLD_WIDTH +1 -1:0] R_wr_data;
  logic B_rd_en, B_wr_en; logic [B_T_PAYLD_WIDTH +1 -1:0] B_wr_data;
  logic pcken;
  //logic WL_rd_en, WL_wr_en;
  logic pd_req, pd_ack, tx_pwr_state, rx_pwr_state;

  modport si (
    input  tx_clk, tx_clk2, tx_reset_n, 
           A_wr_en, A_wr_data, W_wr_en, W_wr_data, R_rd_en, B_rd_en, 
           pcken, pd_req, tx_pwr_state,
    output rx_clk, rx_clk2, rx_reset_n,
           A_rd_en, W_rd_en, R_wr_en, R_wr_data, B_wr_en, B_wr_data,
           pd_ack, rx_pwr_state
  );

  modport mi (
    output tx_clk, tx_clk2, tx_reset_n, 
           A_wr_en, A_wr_data, W_wr_en, W_wr_data, R_rd_en, B_rd_en, 
           pcken, pd_req, tx_pwr_state,
    input  rx_clk, rx_clk2, rx_reset_n,
           A_rd_en, W_rd_en, R_wr_en, R_wr_data, B_wr_en, B_wr_data,
           pd_ack, rx_pwr_state
  );

endinterface

// =============================================================================
interface orbit_if_AXI #(
  parameter ID_WIDTH     = 4,
  parameter ADDR_WIDTH   = 32,
  parameter USER_WIDTH   = 1,
  parameter DATA_WIDTH   = 32,
  // auto calculated
  parameter WSTRB_WIDTH  = DATA_WIDTH / 8
);

  logic ARVALID, ARREADY;
  logic [3:0]               ARQOS;
  logic [7:0]               ARLEN;
  logic [ID_WIDTH - 1:0]    ARID;
  logic [ADDR_WIDTH - 1:0]  ARADDR;
  logic [2:0]               ARSIZE;
  logic [1:0]               ARBURST;
  logic [3:0]               ARCACHE;
  logic [2:0]               ARPROT;
  logic [1:0]               ARLOCK;
  logic [3:0]               ARSNOOP;
  logic [1:0]               ARDOMAIN;
  logic [1:0]               ARBAR;
  logic [USER_WIDTH - 1:0]  ARUSER;

  logic AWVALID, AWREADY;
  logic [3:0]               AWQOS;
  logic [7:0]               AWLEN;
  logic [ID_WIDTH - 1:0]    AWID;
  logic [ADDR_WIDTH - 1:0]  AWADDR;
  logic [2:0]               AWSIZE;
  logic [1:0]               AWBURST;
  logic [3:0]               AWCACHE;
  logic [2:0]               AWPROT;
  logic [1:0]               AWLOCK;
  logic [2:0]               AWSNOOP;
  logic [1:0]               AWDOMAIN;
  logic [1:0]               AWBAR;
  logic [USER_WIDTH - 1:0]  AWUSER;

  logic WVALID, WREADY;
  logic [ID_WIDTH - 1:0]    WID;
  logic [WSTRB_WIDTH - 1:0] WSTRB;
  logic [DATA_WIDTH - 1:0]  WDATA;
  logic                     WLAST;

  logic RVALID, RREADY;
  logic [ID_WIDTH - 1:0]    RID;
  logic [1:0]               RRESP;
  logic [DATA_WIDTH - 1:0]  RDATA;
  logic                     RLAST;
  logic [USER_WIDTH - 1:0]  RUSER;

  logic BVALID, BREADY;
  logic [ID_WIDTH - 1:0]    BID;
  logic [1:0]               BRESP;
  logic [USER_WIDTH - 1:0]  BUSER;

  modport si (
    input ARVALID, output ARREADY,
    input ARQOS,
    input ARLEN,
    input ARID,
    input ARADDR,
    input ARSIZE,
    input ARBURST,
    input ARCACHE,
    input ARPROT,
    input ARLOCK,
    input ARSNOOP,
    input ARDOMAIN,
    input ARBAR,
    input ARUSER,

    input AWVALID, output AWREADY,
    input AWQOS,
    input AWLEN,
    input AWID,
    input AWADDR,
    input AWSIZE,
    input AWBURST,
    input AWCACHE,
    input AWPROT,
    input AWLOCK,
    input AWSNOOP,
    input AWDOMAIN,
    input AWBAR,
    input AWUSER,

    input WVALID, output WREADY,
    input WID,
    input WSTRB,
    input WDATA,
    input WLAST,

    output RVALID, input RREADY,
    output RID,
    output RRESP,
    output RDATA,
    output RLAST,
    output RUSER,

    output BVALID, input BREADY,
    output BID,
    output BRESP,
    output BUSER
  );

  modport mi (
    output ARVALID, input ARREADY,
    output ARQOS,
    output ARLEN,
    output ARID,
    output ARADDR,
    output ARSIZE,
    output ARBURST,
    output ARCACHE,
    output ARPROT,
    output ARLOCK,
    output ARSNOOP,
    output ARDOMAIN,
    output ARBAR,
    output ARUSER,

    output AWVALID, input AWREADY,
    output AWQOS,
    output AWLEN,
    output AWID,
    output AWADDR,
    output AWSIZE,
    output AWBURST,
    output AWCACHE,
    output AWPROT,
    output AWLOCK,
    output AWSNOOP,
    output AWDOMAIN,
    output AWBAR,
    output AWUSER,

    output WVALID, input WREADY,
    output WID,
    output WSTRB,
    output WDATA,
    output WLAST,

    input  RVALID, output RREADY,
    input  RID,
    input  RRESP,
    input  RDATA,
    input  RLAST,
    input  RUSER,

    input  BVALID, output BREADY,
    input  BID,
    input  BRESP,
    input  BUSER
  );

endinterface

// =============================================================================
interface orbit_if_axi_payload #(
  parameter DECODE_WIDTH = 0 ,
  parameter ROUTE_WIDTH  = 0 ,
  parameter ID_WIDTH     = 4 ,
  parameter ADDR_WIDTH   = 32,
  parameter USER_WIDTH   = 1 ,
  parameter DATA_WIDTH   = 32,
  // auto calculated
  parameter AR_PAYLD_WIDTH = 4 + 4 + ID_WIDTH + ADDR_WIDTH + 13 + 2+2 + USER_WIDTH + ROUTE_WIDTH,
  parameter AW_PAYLD_WIDTH = 4 + 4 + ID_WIDTH + ADDR_WIDTH + 13 + 2+2 + USER_WIDTH + ROUTE_WIDTH,
  parameter WSTRB_WIDTH = DATA_WIDTH/8,
  parameter A_PAYLD_WIDTH = 1 + DECODE_WIDTH + 4 + 4 + ID_WIDTH + ADDR_WIDTH + 13 + 2 + 2 + USER_WIDTH + ROUTE_WIDTH,
  parameter W_PAYLD_WIDTH = WSTRB_WIDTH + DATA_WIDTH + 1,
  parameter R_PAYLD_WIDTH = ID_WIDTH + 2 + DATA_WIDTH + 1 + USER_WIDTH + ROUTE_WIDTH,
  parameter B_PAYLD_WIDTH = ID_WIDTH + 2 + USER_WIDTH + ROUTE_WIDTH
);

  logic arv, arr; logic [AR_PAYLD_WIDTH -1:0] arp;
  logic awv, awr; logic [AW_PAYLD_WIDTH -1:0] awp;
  logic  wv,  wr; logic [ W_PAYLD_WIDTH -1:0]  wp;
  logic  rv,  rr; logic [ R_PAYLD_WIDTH -1:0]  rp;
  logic  bv,  br; logic [ B_PAYLD_WIDTH -1:0]  bp;

  modport si (
    input arv, arp, awv, awp, wv, wp, rr, br,
    output arr, awr, wr, rv, rp, bv, bp
  );

  modport mi (
    output arv, arp, awv, awp, wv, wp, rr, br,
    input arr, awr, wr, rv, rp, bv, bp
  );

endinterface


`include "oic_undef.h"
`endif

// vim: tabstop=2 expandtab softtabstop=2 shiftwidth=2 smarttab

